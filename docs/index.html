<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="utf-8">
    <title>JSDoc: Home</title>

    <script src="scripts/prettify/prettify.js"> </script>
    <script src="scripts/prettify/lang-css.js"> </script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <link type="text/css" rel="stylesheet" href="styles/prettify-tomorrow.css">
    <link type="text/css" rel="stylesheet" href="styles/jsdoc-default.css">
</head>

<body>

<div id="main">

    <h1 class="page-title">Home</h1>

    



    


    <h3> </h3>










    




    <section>
        <article><h1>PeerPigeon <img src="examples/browser/assets/images/favicon.png" alt="PeerPigeon Logo" width="32" height="32" align="right"></h1>
<p><strong>A WebRTC-based peer-to-peer mesh networking library with intelligent routing, gossip protocol messaging, and automated peer management.</strong></p>
<p><a href="https://badge.fury.io/js/peerpigeon"><img src="https://badge.fury.io/js/peerpigeon.svg" alt="npm version"></a>
<a href="https://opensource.org/licenses/MIT"><img src="https://img.shields.io/badge/License-MIT-yellow.svg" alt="License: MIT"></a>
<a href="https://github.com/draeder/peerpigeon"><img src="https://img.shields.io/badge/Tests-23%2F23%20passing-brightgreen.svg" alt="Tests"></a>
<a href="https://github.com/draeder/peerpigeon"><img src="https://img.shields.io/badge/ESLint-0%20errors-brightgreen.svg" alt="ESLint"></a></p>
<blockquote>
<p><strong>📊 Viewing Diagrams</strong>: This README contains Mermaid diagrams. For proper visualization in VS Code, install the <a href="https://marketplace.visualstudio.com/items?itemName=bierner.markdown-mermaid">Markdown Preview Mermaid Support</a> extension.</p>
</blockquote>
<h2>🌟 Features</h2>
<ul>
<li><strong>🕸️ True Mesh Networking</strong>: Gossip protocol ensures messages reach all peers, not just direct connections</li>
<li><strong>📐 XOR Distance Routing</strong>: Kademlia-inspired peer selection for optimal network topology</li>
<li><strong>🧠 Smart Eviction Strategy</strong>: Automatically replaces distant peers with closer ones to optimize mesh topology</li>
<li><strong>🔍 Auto-Discovery</strong>: Seamlessly connects to peers as they join the network</li>
<li><strong>⚡ WebSocket Signaling</strong>: Real-time bidirectional communication for optimal performance</li>
<li><strong>�️ Distributed Hash Table (WebDHT)</strong>: Store and retrieve data across the mesh with automatic replication</li>
<li><strong>🎥 Media Streaming</strong>: Built-in support for audio/video streaming between peers</li>
<li><strong>💬 Messaging System</strong>: Direct messages and broadcast gossip protocol messaging</li>
<li><strong>🔧 Modular Architecture</strong>: Clean separation of concerns with event-driven components</li>
<li><strong>💰 Cost-Optimized</strong>: XOR-based routing reduces signaling server costs by ~95%</li>
<li><strong>🛡️ Memory Safe</strong>: Comprehensive cleanup prevents memory leaks in long-running applications</li>
</ul>
<h2>🏗️ Architecture Overview</h2>
<pre class="prettyprint source lang-mermaid"><code>graph TB
    subgraph Browser[Browser Environment]
        UI[User Interface] --> App[PeerPigeonMesh]
        
        App --> SC[SignalingClient]
        App --> PD[PeerDiscovery]
        App --> CM[ConnectionManager]
        App --> EM[EvictionManager]
        App --> GM[GossipManager]
        App --> MO[MeshOptimizer]
        
        CM --> PC1[PeerConnection A]
        CM --> PC2[PeerConnection B]
        CM --> PC3[PeerConnection ...]
        
        GM --> PC1
        GM --> PC2
        GM --> PC3
    end
    
    subgraph Network[Network Layer]
        PC1 -.->|WebRTC Data Channel| PA[Peer A]
        PC2 -.->|WebRTC Data Channel| PB[Peer B]
        PC3 -.->|WebRTC Data Channel| PC[Peer ...]
    end
    
    subgraph Signaling[Signaling Infrastructure]
        SC -->|HTTP/WebSocket| SS[Signaling Server]
        SS --> DB[(Message Storage)]
    end
    
    style App fill:#e1f5fe,color:#000000
    style GM fill:#e8f5e8,color:#000000
    style EM fill:#fff3e0,color:#000000
    style PD fill:#fce4ec,color:#000000
</code></pre>
<blockquote>
<p><strong>Note</strong>: If diagrams don't display, install the <a href="https://marketplace.visualstudio.com/items?itemName=bierner.markdown-mermaid">Markdown Preview Mermaid Support</a> extension in VS Code.</p>
</blockquote>
<h2>🚀 Quick Start</h2>
<h3>Installation</h3>
<pre class="prettyprint source lang-bash"><code># Install PeerPigeon from npm
npm install peerpigeon
</code></pre>
<h3>Basic Setup</h3>
<pre class="prettyprint source lang-javascript"><code>import { PeerPigeonMesh } from 'peerpigeon';

// Create mesh instance
const mesh = new PeerPigeonMesh({
    enableWebDHT: true, // Enable distributed hash table (default: true)
    peerId: 'custom-peer-id' // Optional: provide custom peer ID
});

// Initialize and connect
await mesh.init();
await mesh.connect('ws://localhost:3000'); // Your signaling server URL
</code></pre>
<h3>Starting a WebSocket Server</h3>
<h4>Option 1: Programmatic Server Setup (Recommended)</h4>
<pre class="prettyprint source lang-javascript"><code>import { PeerPigeonServer } from 'peerpigeon';

// Create and start the server
const server = new PeerPigeonServer({
    port: 3000,
    host: 'localhost',
    maxConnections: 1000,
    cleanupInterval: 60000, // 1 minute
    peerTimeout: 300000     // 5 minutes
});

// Start the server
await server.start();

// Listen for events
server.on('peerConnected', ({ peerId, totalConnections }) => {
    console.log(`Peer ${peerId} connected. Total: ${totalConnections}`);
});

server.on('peerDisconnected', ({ peerId, totalConnections }) => {
    console.log(`Peer ${peerId} disconnected. Total: ${totalConnections}`);
});

// Graceful shutdown
process.on('SIGINT', async () => {
    await server.stop();
    process.exit(0);
});
</code></pre>
<h4>Option 2: Standalone Server</h4>
<pre class="prettyprint source lang-bash"><code># Run the standalone server (from npm package)
npm start

# Or run directly with custom configuration
PORT=8080 HOST=0.0.0.0 npm start
</code></pre>
<h3>Messaging Examples</h3>
<pre class="prettyprint source lang-javascript"><code>// Send a broadcast message to all peers
const messageId = mesh.sendMessage('Hello, mesh network!');

// Send a direct message to a specific peer
const directMessageId = mesh.sendDirectMessage('target-peer-id', 'Private message');

// Listen for incoming messages
mesh.addEventListener('messageReceived', (data) => {
    console.log(`Message from ${data.from}: ${data.content}`);
    console.log(`Direct message: ${data.direct}`);
});
</code></pre>
<h3>WebDHT (Distributed Hash Table) Examples</h3>
<pre class="prettyprint source lang-javascript"><code>// Store data in the distributed hash table
await mesh.dhtPut('user-settings', { theme: 'dark', language: 'en' });

// Retrieve data from the DHT
const settings = await mesh.dhtGet('user-settings');

// Subscribe to changes
await mesh.dhtSubscribe('shared-counter');
mesh.addEventListener('dhtValueChanged', (data) => {
    console.log(`Key ${data.key} changed to:`, data.newValue);
});

// Update a value and notify subscribers
await mesh.dhtUpdate('shared-counter', 42);
</code></pre>
<h3>Media Streaming Examples</h3>
<pre class="prettyprint source lang-javascript"><code>// Start local video stream
const stream = await mesh.startMedia({ video: true, audio: true });

// Toggle media
mesh.toggleVideo(); // Enable/disable video
mesh.toggleAudio(); // Enable/disable audio

// Get media devices
const devices = await mesh.enumerateMediaDevices();
console.log('Available cameras:', devices.cameras);
console.log('Available microphones:', devices.microphones);

// Listen for remote streams
mesh.addEventListener('remoteStream', (data) => {
    const { peerId, stream } = data;
    const videoElement = document.createElement('video');
    videoElement.srcObject = stream;
    videoElement.play();
});
</code></pre>
<h3>Event Handling Examples</h3>
<pre class="prettyprint source lang-javascript"><code>// Connection events
mesh.addEventListener('connected', () => {
    console.log('Connected to signaling server');
});

mesh.addEventListener('peerConnected', (data) => {
    console.log(`Peer connected: ${data.peerId}`);
});

mesh.addEventListener('peerDisconnected', (data) => {
    console.log(`Peer disconnected: ${data.peerId}, reason: ${data.reason}`);
});

// Status monitoring
mesh.addEventListener('statusChanged', (data) => {
    console.log(`Status: ${data.type} - ${data.message}`);
});
</code></pre>
<h3>Configuration Examples</h3>
<pre class="prettyprint source lang-javascript"><code>// Adjust mesh topology
mesh.setMaxPeers(5);     // Maximum peer connections
mesh.setMinPeers(2);     // Minimum peer connections
mesh.setXorRouting(true); // Enable XOR-based routing
mesh.setEvictionStrategy(true); // Enable smart peer eviction

// Get current status
const status = mesh.getStatus();
console.log('Connected peers:', status.connectedCount);
console.log('Discovered peers:', status.discoveredCount);
</code></pre>
<h3>Local Development Server</h3>
<p><strong>Option 1: Using npm package (Recommended)</strong></p>
<pre class="prettyprint source lang-bash"><code># Install PeerPigeon globally or in your project
npm install peerpigeon

# Start the signaling server
npm start

# Or with custom configuration
PORT=8080 HOST=0.0.0.0 npm start

# Serve the browser examples using the built-in server
npm run dev
</code></pre>
<p><strong>Option 2: From source (for development)</strong></p>
<pre class="prettyprint source lang-bash"><code># Clone the repository
git clone https://github.com/draeder/peerpigeon.git
cd peerpigeon

# Start the WebSocket signaling server
npm start

# Serve the browser examples
npm run dev
</code></pre>
<h4>Navigate to http://localhost:8080/examples/browser/</h4>
<h6>Test with query parameters</h6>
<p>http://localhost:8080/examples/browser/?api=ws://localhost:3000</p>
<h2>🔄 System Flow Diagrams</h2>
<h3>Peer Discovery &amp; Connection Flow</h3>
<pre class="prettyprint source lang-mermaid"><code>sequenceDiagram
    participant A as Peer A
    participant B as Peer B  
    participant C as Peer C
    participant S as Signaling Server
    
    Note over A,C: Network Formation
    A->>S: announce (peerId, timestamp)
    B->>S: announce (peerId, timestamp)
    C->>S: announce (peerId, timestamp)
    
    S->>A: peer-discovered (B, C)
    S->>B: peer-discovered (A, C)
    S->>C: peer-discovered (A, B)
    
    Note over A,C: Smart Connection Logic
    A->>A: shouldInitiate(B)? (A > B lexicographically)
    A->>B: WebRTC offer (if true)
    B->>A: WebRTC answer
    
    A->>B: ICE candidate
    B->>A: ICE candidate
    Note over A,B: ✅ WebRTC Data Channel Ready
    
    Note over A,C: Topology Optimization
    C->>A: connection request
    A->>A: at capacity? should evict?
    A->>B: eviction notice (if applicable)
    Note over A,C: ✅ Connection established
</code></pre>
<h3>Gossip Protocol Message Flow</h3>
<pre class="prettyprint source lang-mermaid"><code>flowchart TD
    Send[User sends message] --> CreateMsg[&quot;Create gossip message&lt;br/>with ID, TTL=10&quot;]
    CreateMsg --> StoreLocal[&quot;Store in seen messages&lt;br/>to prevent loops&quot;]
    StoreLocal --> EmitLocal[Emit to local UI]
    EmitLocal --> Broadcast[Send to all connected peers]
    
    Receive[Receive gossip message] --> CheckSeen{Already seen this message?}
    CheckSeen -->|Yes| Drop[Drop message]
    CheckSeen -->|No| CheckTTL{TTL > 0?}
    CheckTTL -->|No| Drop
    CheckTTL -->|Yes| CheckLoop{Sender in our path?}
    CheckLoop -->|Yes| Drop
    CheckLoop -->|No| Process[Process message]
    
    Process --> StoreSeen[Store in seen messages]
    StoreSeen --> EmitReceived[Emit to local UI]
    EmitReceived --> DecrementTTL[&quot;TTL--, add to path&quot;]
    DecrementTTL --> Propagate[&quot;Forward to other peers&lt;br/>except sender&quot;]
    
    Propagate --> End[Message delivered]
    Drop --> End
    
    style Send fill:#e8f5e8,color:#000000
    style Receive fill:#e1f5fe,color:#000000
    style Drop fill:#ffebee,color:#000000
    style End fill:#f3e5f5,color:#000000
</code></pre>
<h3>Peer Connection &amp; Isolation Prevention</h3>
<pre class="prettyprint source lang-mermaid"><code>flowchart TD
    Discover[Peer Discovered] --> ShouldInit{Should we initiate connection?}
    
    ShouldInit --> CheckLex[&quot;Lexicographic rule:&lt;br/>our ID > target ID?&quot;]
    CheckLex -->|Yes| Connect[Initiate Connection]
    CheckLex -->|No| CheckIsolation{Are we isolated?}
    
    CheckIsolation -->|No connections| IsolationOverride[&quot;Override lexicographic rule&lt;br/>to prevent isolation&quot;]
    CheckIsolation -->|Has connections| Wait[Wait for peer to initiate to us]
    
    IsolationOverride --> NaturalInitiator{Can initiate to natural targets?}
    NaturalInitiator -->|Yes| ConnectNatural[&quot;Connect to peer where&lt;br/>we're natural initiator&quot;]
    NaturalInitiator -->|No| ConnectClosest[&quot;Connect to closest peer&lt;br/>by XOR distance&quot;]
    
    ConnectNatural --> Connect
    ConnectClosest --> Connect
    
    Connect --> WebRTC[&quot;WebRTC Handshake&lt;br/>via signaling server&quot;]
    WebRTC --> Success{Connection successful?}
    
    Success -->|Yes| CheckCapacity{At peer capacity?}
    Success -->|No| RetryLater[&quot;Retry with&lt;br/>exponential backoff&quot;]
    
    CheckCapacity -->|No| Maintain[Maintain connection]
    CheckCapacity -->|Yes| ConsiderEviction[&quot;Should evict&lt;br/>existing peer?&quot;]
    
    ConsiderEviction -->|No| Maintain
    ConsiderEviction -->|Yes| EvictFarthest[&quot;Evict farthest peer&lt;br/>by XOR distance&quot;]
    
    EvictFarthest --> Maintain
    Wait --> End[End]
    RetryLater --> End
    Maintain --> End
    
    style Discover fill:#e1f5fe,color:#000000
    style IsolationOverride fill:#fff3e0,color:#000000
    style EvictFarthest fill:#ffebee,color:#000000
    style Maintain fill:#e8f5e8,color:#000000
</code></pre>
<h3>Smart Eviction Strategy</h3>
<pre class="prettyprint source lang-mermaid"><code>flowchart TD
    NewPeer[Incoming Connection Request] --> AtCapacity{At maximum peer capacity?}
    
    AtCapacity -->|No| Accept[Accept Connection]
    AtCapacity -->|Yes| CalcDistance[&quot;Calculate XOR distance&lt;br/>from our peer ID&quot;]
    
    CalcDistance --> FindFarthest[&quot;Find currently farthest&lt;br/>connected peer&quot;]
    FindFarthest --> Compare[&quot;New peer closer&lt;br/>than farthest peer?&quot;]
    
    Compare -->|No| Reject[&quot;Reject connection&lt;br/>not worth evicting for&quot;]
    Compare -->|Yes| SendEviction[&quot;Send eviction notice&lt;br/>to farthest peer&quot;]
    
    SendEviction --> DisconnectFarthest[Disconnect farthest peer]
    DisconnectFarthest --> AcceptNew[Accept new peer connection]
    
    AcceptNew --> OptimalTopology[&quot;Maintain optimal&lt;br/>mesh topology&quot;]
    
    Accept --> End[Connection Complete]
    Reject --> End
    OptimalTopology --> End
    
    style NewPeer fill:#e1f5fe,color:#000000
    style SendEviction fill:#fff3e0,color:#000000
    style DisconnectFarthest fill:#ffebee,color:#000000
    style AcceptNew fill:#e8f5e8,color:#000000
</code></pre>
<h2>� API Reference</h2>
<h3>PeerPigeonServer Class</h3>
<p>When importing the server class, you can create and configure it programmatically:</p>
<pre class="prettyprint source lang-javascript"><code>import { PeerPigeonServer } from 'peerpigeon';

const server = new PeerPigeonServer(options);
</code></pre>
<h4>Constructor Options</h4>
<ul>
<li><strong><code>port</code></strong> (number) - Server port (default: 3000)</li>
<li><strong><code>host</code></strong> (string) - Server host (default: 'localhost')</li>
<li><strong><code>maxConnections</code></strong> (number) - Maximum concurrent connections (default: 1000)</li>
<li><strong><code>cleanupInterval</code></strong> (number) - Cleanup interval in ms (default: 60000)</li>
<li><strong><code>peerTimeout</code></strong> (number) - Peer timeout in ms (default: 300000)</li>
<li><strong><code>corsOrigin</code></strong> (string) - CORS origin (default: '*')</li>
<li><strong><code>maxMessageSize</code></strong> (number) - Max message size in bytes (default: 1MB)</li>
</ul>
<h4>Methods</h4>
<ul>
<li><strong><code>await server.start()</code></strong> - Start the server</li>
<li><strong><code>await server.stop()</code></strong> - Stop the server</li>
<li><strong><code>server.getStats()</code></strong> - Get server statistics</li>
<li><strong><code>server.getPeers()</code></strong> - Get list of connected peers</li>
</ul>
<h4>Events</h4>
<ul>
<li><strong><code>started</code></strong> - Server started</li>
<li><strong><code>stopped</code></strong> - Server stopped</li>
<li><strong><code>peerConnected</code></strong> - Peer connected</li>
<li><strong><code>peerDisconnected</code></strong> - Peer disconnected</li>
<li><strong><code>peerAnnounced</code></strong> - Peer announced</li>
<li><strong><code>peerGoodbye</code></strong> - Peer said goodbye</li>
<li><strong><code>error</code></strong> - Server error</li>
</ul>
<h4>Example: Custom Server Configuration</h4>
<pre class="prettyprint source lang-javascript"><code>import { PeerPigeonServer } from 'peerpigeon';

const server = new PeerPigeonServer({
    port: 8080,
    maxConnections: 500,
    cleanupInterval: 30000
});

server.on('peerConnected', ({ peerId, totalConnections }) => {
    console.log(`New peer: ${peerId}, Total: ${totalConnections}`);
});

await server.start();
</code></pre>
<h3>Client Library Exports</h3>
<pre class="prettyprint source lang-javascript"><code>import { PeerPigeonMesh, PeerPigeonServer } from 'peerpigeon';
</code></pre>
<ul>
<li><strong><code>PeerPigeonMesh</code></strong> - Main mesh networking class (browser)</li>
<li><strong><code>PeerPigeonServer</code></strong> - WebSocket signaling server class (Node.js)</li>
<li><strong><code>PeerConnection</code></strong> - WebRTC peer connection wrapper</li>
<li><strong><code>SignalingClient</code></strong> - WebSocket signaling client</li>
<li><strong><code>WebDHT</code></strong> - Distributed hash table implementation</li>
</ul>
<h2>�📚 Core Components</h2>
<h3>PeerPigeonMesh</h3>
<p>Central coordinator that manages all mesh networking functionality and orchestrates the component interactions.</p>
<pre class="prettyprint source lang-javascript"><code>const mesh = new PeerPigeonMesh();
await mesh.init();
await mesh.connect('wss://your-signaling-server.com');

// Send message to entire network via gossip protocol
const messageId = mesh.sendMessage('Hello mesh network!');

// Get network status
const status = mesh.getStatus();
console.log(`Connected to ${status.connectedCount}/${status.maxPeers} peers`);

// Configure mesh behavior
mesh.setMaxPeers(10);
mesh.setAutoDiscovery(true);
mesh.setEvictionStrategy(true);
</code></pre>
<h3>PeerDiscovery</h3>
<p>Manages peer discovery and implements smart connection logic with isolation prevention.</p>
<p><strong>Key Features:</strong></p>
<ul>
<li><strong>Lexicographic connection rule</strong> prevents connection race conditions</li>
<li><strong>Isolation override</strong> ensures peers with no connections can still connect</li>
<li><strong>XOR distance sorting</strong> prioritizes closer peers for optimal topology</li>
<li><strong>Connection attempt tracking</strong> prevents duplicate connection attempts</li>
</ul>
<pre class="prettyprint source lang-javascript"><code>// Example of isolation override logic
if (currentConnectionCount === 0 && discoveredPeers.length > 0) {
    // Override lexicographic rule to prevent isolation
    // Priority: natural initiators > closest peer by XOR distance
}
</code></pre>
<h3>ConnectionManager</h3>
<p>Manages WebRTC peer connections, handles signaling, and routes messages to appropriate handlers.</p>
<p><strong>Responsibilities:</strong></p>
<ul>
<li>WebRTC connection establishment and management</li>
<li>Message routing to GossipManager and EvictionManager</li>
<li>Connection state tracking and cleanup</li>
<li>Retry logic with exponential backoff</li>
<li>Race condition prevention</li>
</ul>
<h3>GossipManager</h3>
<p>Implements gossip protocol for reliable message propagation across the entire mesh network.</p>
<p><strong>Protocol Features:</strong></p>
<ul>
<li><strong>TTL (Time To Live)</strong>: Messages expire after 10 hops to prevent infinite loops</li>
<li><strong>Seen message tracking</strong>: Prevents duplicate message processing</li>
<li><strong>Path tracking</strong>: Detects and prevents routing loops</li>
<li><strong>Broadcast guarantee</strong>: Messages reach all peers, not just direct connections</li>
</ul>
<pre class="prettyprint source lang-javascript"><code>// Gossip message structure
{
    id: 'unique-message-id',
    type: 'gossip',
    subtype: 'chat',
    content: 'Hello network!',
    from: 'sender-peer-id',
    timestamp: Date.now(),
    ttl: 10,
    path: ['sender-peer-id', 'relay-peer-id', ...]
}
</code></pre>
<h3>EvictionManager</h3>
<p>Implements smart peer eviction for optimal mesh topology using XOR distance calculations.</p>
<p><strong>Eviction Strategy:</strong></p>
<ul>
<li>Only evicts when at maximum peer capacity</li>
<li>Calculates XOR distances to determine peer relationships</li>
<li>Evicts farthest peer when a closer one wants to connect</li>
<li>Sends eviction notices before disconnecting peers</li>
<li>No cooldown periods - focuses purely on topology optimization</li>
</ul>
<h3>MeshOptimizer</h3>
<p>Handles periodic mesh optimization and provides debugging utilities.</p>
<p><strong>Optimization Features:</strong></p>
<ul>
<li>Periodic connectivity analysis</li>
<li>Force connection to all discovered peers (for testing)</li>
<li>Mesh topology evaluation and recommendations</li>
</ul>
<h2>⚙️ Configuration &amp; API</h2>
<p>The PeerPigeonMesh API provides methods for configuration, network management, messaging, and debugging. It is designed to be intuitive and event-driven.</p>
<h3>Initialization &amp; Connection</h3>
<p>Methods to initialize the mesh and manage the connection to the signaling server.</p>
<pre class="prettyprint source lang-javascript"><code>// Initialize the mesh with a new, cryptographically secure peer ID.
// This must be called before any other method.
await mesh.init();

// Connect to the signaling server to join the mesh network.
await mesh.connect(signalingUrl);

// Disconnect from the signaling server and all connected peers.
mesh.disconnect();
</code></pre>
<h3>Configuration</h3>
<p>Configure the behavior of the mesh network. These setters can be called at any time.</p>
<pre class="prettyprint source lang-javascript"><code>// Set the maximum number of concurrent peer connections.
// Default: 3, Min: 1, Max: 50
mesh.setMaxPeers(10);

// Set the minimum number of connections to maintain for network health.
// Default: 2, Min: 0, Max: 49
mesh.setMinPeers(2);

// Enable or disable automatic connection to newly discovered peers.
// Default: true
mesh.setAutoDiscovery(true);

// Enable or disable the smart eviction strategy to optimize topology.
// Default: true
mesh.setEvictionStrategy(true);

// Enable or disable XOR distance-based routing for peer selection.
// Default: true
mesh.setXorRouting(true);

// Enable or disable the WebDHT (Distributed Hash Table) functionality.
// When disabled, all DHT methods will throw errors with helpful messages.
// Default: true (enabled)
// Can only be set during initialization in constructor options
const mesh = new PeerPigeonMesh({ enableWebDHT: false }); // Disable DHT

// Set the signaling connection type. Currently only 'websocket' is supported.
// Default: 'websocket'
mesh.setConnectionType('websocket');
</code></pre>
<h3>Network &amp; Peer Information</h3>
<p>Retrieve information about the network state and connected peers.</p>
<pre class="prettyprint source lang-javascript"><code>// Get a comprehensive status object with the current state of the mesh.
// See &quot;Status Object Structure&quot; below for details.
const status = mesh.getStatus();

// Get the number of currently connected peers.
const count = mesh.getConnectedPeerCount();

// Get an array of peer IDs for all connected peers.
const peers = mesh.getPeers();

// Get an array of peer IDs for all discovered but not-yet-connected peers.
const discovered = mesh.getDiscoveredPeers();

// Check if the mesh can accept new incoming connections (i.e., not at maxPeers).
const canAccept = mesh.canAcceptMorePeers();

// Check if a peer is currently connected.
const isConnected = mesh.hasPeer(peerId);
</code></pre>
<h3>Messaging</h3>
<p>Send messages to other peers in the network.</p>
<pre class="prettyprint source lang-javascript"><code>// Broadcast a message to the entire mesh network using the gossip protocol.
// Returns a unique ID for the message.
const messageId = mesh.sendMessage(content);
</code></pre>
<h3>Manual Peer Management</h3>
<p>Manually control connections to specific peers.</p>
<pre class="prettyprint source"><code>
### Event System

```javascript
// === Connection Events ===
mesh.addEventListener('peerConnected', (event) => {
    console.log(`✅ Peer connected: ${event.peerId.substring(0, 8)}...`);
});

mesh.addEventListener('peerDisconnected', (event) => {
    console.log(`❌ Peer disconnected: ${event.peerId.substring(0, 8)}... (${event.reason})`);
});

mesh.addEventListener('peerDiscovered', (event) => {
    console.log(`🔍 Peer discovered: ${event.peerId.substring(0, 8)}...`);
});

// === Messaging Events ===
mesh.addEventListener('messageReceived', (event) => {
    console.log(`💬 Message from ${event.from.substring(0, 8)}...: &quot;${event.content}&quot;`);
    console.log(`   Direct: ${event.direct}, Hops: ${event.hops || 0}`);
});

// === Network Events ===
mesh.addEventListener('peerEvicted', (event) => {
    console.log(`🔄 Peer evicted: ${event.peerId.substring(0, 8)}... (${event.reason})`);
});

mesh.addEventListener('statusChanged', (event) => {
    console.log(`📊 Status: ${event.type} - ${event.message}`);
});

mesh.addEventListener('peersUpdated', () => {
    console.log(`📈 Peer list updated - Connected: ${mesh.getConnectedPeerCount()}`);
});
</code></pre>
<h3>Status Object Structure</h3>
<pre class="prettyprint source lang-javascript"><code>const status = mesh.getStatus();
// Returns:
{
    peerId: &quot;abc123...&quot;,              // Our peer ID
    connected: true,                  // Connected to signaling server
    connectedCount: 3,                // Number of connected peers
    discoveredCount: 5,               // Number of discovered peers
    maxPeers: 10,                     // Maximum peer limit
    minPeers: 2,                      // Minimum peer target
    autoDiscovery: true,              // Auto-discovery enabled
    evictionStrategy: true,           // Smart eviction enabled
    xorRouting: true,                 // XOR-based routing enabled
    connectionType: &quot;websocket&quot;,      // Current signaling method
    signalingUrl: &quot;wss://...&quot;,        // Signaling server URL
    uptime: 120000                    // Milliseconds since connection
}
</code></pre>
<h2>🌐 Network Topology &amp; XOR Routing</h2>
<h3>XOR Distance Calculation</h3>
<p>PeerPigeon uses XOR distance (inspired by Kademlia DHT) to determine peer relationships:</p>
<pre class="prettyprint source lang-javascript"><code>// Example XOR distance calculation
function calculateXorDistance(peerId1, peerId2) {
    let distance = 0n;
    for (let i = 0; i &lt; Math.min(peerId1.length, peerId2.length); i += 2) {
        const byte1 = parseInt(peerId1.substr(i, 2), 16);
        const byte2 = parseInt(peerId2.substr(i, 2), 16);
        const xor = byte1 ^ byte2;
        distance = (distance &lt;&lt; 8n) | BigInt(xor);
    }
    return distance;
}

// Peer A: 0x1234abcd...
// Peer B: 0x1345cdef...
// XOR:    0x0071661e... (smaller = closer)
</code></pre>
<h3>Topology Example</h3>
<pre class="prettyprint source lang-mermaid"><code>graph TB
    subgraph MeshNetwork[Mesh Network with XOR Distance Optimization]
        A[Peer A: 0x1234...]
        B[Peer B: 0x1345...]  
        C[Peer C: 0x5678...]
        D[Peer D: 0x9ABC...]
        E[Peer E: 0x9BCD...]
    end
    
    A -->|Direct connection XOR small| B
    A -->|Direct connection XOR medium| C
    A -.->|Would connect if capacity| D
    
    B -->|Direct connection XOR small| A
    B -->|Direct connection XOR large| C
    
    C -->|Direct connection XOR medium| A
    C -->|Direct connection XOR large| B
    C -.->|Would evict B for| D
    
    D -.->|Very close XOR distance| E
    D -->|Would connect to| C
    
    E -.->|Very close XOR distance| D
    E -->|Would evict distant peer to connect to D| D
    
    style A fill:#e1f5fe,color:#000000
    style B fill:#e8f5e8,color:#000000
    style C fill:#fff3e0,color:#000000
    style D fill:#fce4ec,color:#000000
    style E fill:#f3e5f5,color:#000000
</code></pre>
<h3>XOR Distance Benefits</h3>
<ol>
<li><strong>Optimal Peer Selection</strong>: Peers with smaller XOR distances are preferred for connections</li>
<li><strong>Efficient Message Routing</strong>: Gossip protocol naturally routes through relevant connections</li>
<li><strong>Scalable Discovery</strong>: New peers only notify the closest existing peers, reducing overhead</li>
<li><strong>Network Resilience</strong>: Multiple paths through the mesh ensure message delivery</li>
<li><strong>Cost Optimization</strong>: Reduces signaling server load by ~95% through smart peer targeting</li>
</ol>
<h3>Isolation Prevention</h3>
<p>The isolation prevention mechanism ensures network connectivity:</p>
<pre class="prettyprint source lang-javascript"><code>// Isolation override logic in PeerDiscovery
if (currentConnectionCount === 0 && discoveredPeers.length > 0) {
    // Step 1: Try to connect to peers where we're the natural initiator
    const naturalInitiators = discoveredPeers.filter(peerId => this.peerId > peerId);
    
    if (naturalInitiators.length > 0) {
        // Connect to natural targets first
        return naturalInitiators.includes(targetPeerId);
    }
    
    // Step 2: If no natural targets, connect to closest peer by XOR distance
    const sortedByDistance = discoveredPeers.sort((a, b) => {
        const distA = calculateXorDistance(this.peerId, a);
        const distB = calculateXorDistance(this.peerId, b);
        return distA &lt; distB ? -1 : 1;
    });
    
    return sortedByDistance[0] === targetPeerId;
}
</code></pre>
<h2>🔗 WebSocket Signaling</h2>
<p>PeerPigeon uses WebSocket signaling for real-time, bidirectional communication:</p>
<h3>WebSocket Signaling - Real-time Communication</h3>
<ul>
<li><strong>Real-time delivery</strong>: Instant bidirectional message delivery</li>
<li><strong>Cost-efficient</strong>: Persistent connections reduce connection overhead</li>
<li><strong>Modern browsers</strong>: Chrome, Firefox, Safari, Edge with full support</li>
<li><strong>Use case</strong>: Production applications requiring real-time performance</li>
</ul>
<pre class="prettyprint source lang-javascript"><code>// WebSocket signaling is used by default
const mesh = new PeerPigeonMesh();
await mesh.connect('wss://your-websocket-server.com');

// WebSocket connection automatically handles:
// - Real-time peer discovery notifications
// - WebRTC signaling message delivery
// - Bidirectional communication
// - Connection state management
</code></pre>
<h3>WebSocket Protocol Messages</h3>
<p>The WebSocket signaling supports these message types:</p>
<table>
<thead>
<tr>
<th>Message Type</th>
<th>Purpose</th>
<th>Data Structure</th>
</tr>
</thead>
<tbody>
<tr>
<td><code>announce</code></td>
<td>Peer joins network</td>
<td><code>{peerId, timestamp}</code></td>
</tr>
<tr>
<td><code>goodbye</code></td>
<td>Peer leaves network</td>
<td><code>{peerId, timestamp}</code></td>
</tr>
<tr>
<td><code>offer</code></td>
<td>WebRTC connection offer</td>
<td><code>{type: 'offer', data: RTCSessionDescription, targetPeerId}</code></td>
</tr>
<tr>
<td><code>answer</code></td>
<td>WebRTC connection answer</td>
<td><code>{type: 'answer', data: RTCSessionDescription, targetPeerId}</code></td>
</tr>
<tr>
<td><code>ice-candidate</code></td>
<td>ICE candidate exchange</td>
<td><code>{type: 'ice-candidate', data: RTCIceCandidate, targetPeerId}</code></td>
</tr>
<tr>
<td><code>cleanup</code></td>
<td>Remove processed messages</td>
<td><code>{type: 'cleanup', reason}</code></td>
</tr>
</tbody>
</table>
<h2>🚀 Deployment Options</h2>
<h3>Option 1: Custom Signaling Server</h3>
<p>Implement your own signaling server with these required endpoints:</p>
<pre class="prettyprint source lang-typescript"><code>// Required endpoints for custom signaling server

// WebSocket connection endpoint
wss://your-server.com/signaling?peerId={peerId}

// WebSocket message format for all signaling messages:
{
    &quot;type&quot;: &quot;offer|answer|ice-candidate|announce|goodbye|ping&quot;,
    &quot;data&quot;: &quot;message-specific-data&quot;,
    &quot;fromPeerId&quot;: &quot;sender-peer-id&quot;,
    &quot;targetPeerId&quot;: &quot;recipient-peer-id&quot;, // optional for broadcasts
    &quot;timestamp&quot;: 1234567890
}
</code></pre>
<h3>Option 2: Development/Testing Setup</h3>
<p>For local development and testing:</p>
<pre class="prettyprint source lang-bash"><code>For local development and testing:

```bash
# Serve with npm (preferred)
npm run dev

# Or with Node.js http-server
npm install -g http-server
http-server -p 8080
</code></pre>
<h1>Use query parameters to pre-configure signaling</h1>
<p>open &quot;http://localhost:8080/examples/browser/?api=wss://your-signaling-server.com/dev&quot;</p>
<pre class="prettyprint source"><code>
**Development Features:**
- Browser debugging tools integration
- Console logging with peer ID prefixes
- Global mesh access via `window.peerPigeonMesh`
- Force connection utilities for testing
- Real-time peer discovery and connection monitoring

## 🌐 Browser Compatibility & Requirements

### Required Browser Features
- **WebRTC**: RTCPeerConnection and RTCDataChannel support
- **ES6 Modules**: Dynamic imports and module syntax  
- **Crypto API**: For cryptographically secure peer ID generation
- **WebSocket API**: For real-time signaling communication

### Supported Browsers & Versions

| Browser | Minimum Version | WebRTC Support | WebSocket Support | Status |
|---------|----------------|----------------|-------------------|---------|
| **Chrome** | 80+ | ✅ Full | ✅ Yes | **Recommended** |
| **Firefox** | 75+ | ✅ Full | ✅ Yes | **Recommended** |
| **Safari** | 14+ | ✅ Full | ✅ Yes | **Supported** |
| **Edge** | 80+ | ✅ Full | ✅ Yes | **Supported** |
| **Mobile Chrome** | 80+ | ✅ Full | ✅ Yes | **Supported** |
| **Mobile Safari** | 14+ | ✅ Full | ✅ Yes | **Supported** |

### Feature Detection

PeerPigeon automatically detects browser capabilities:

```javascript
// Automatic capability detection
const mesh = new PeerPigeonMesh();
await mesh.init(); // Detects WebRTC, WebSocket support

// Check detected capabilities
const status = mesh.getStatus();
console.log('Connection type:', status.connectionType); // 'websocket'
console.log('WebRTC support:', mesh.hasWebRTCSupport());
console.log('WebSocket support:', mesh.hasWebSocketSupport());
</code></pre>
<h2>⚡ Performance &amp; Scalability</h2>
<h3>Network Efficiency</h3>
<ul>
<li><strong>Gossip TTL</strong>: Messages expire after 10 hops to prevent network flooding</li>
<li><strong>XOR Routing</strong>: Only relevant peers receive discovery notifications (~95% reduction)</li>
<li><strong>Connection Limits</strong>: Configurable peer limits prevent resource exhaustion</li>
<li><strong>Smart Eviction</strong>: Maintains optimal topology without unnecessary reconnections</li>
</ul>
<h3>Performance Metrics</h3>
<p>Based on testing with browser networks:</p>
<table>
<thead>
<tr>
<th>Network Size</th>
<th>Avg Connection Time</th>
<th>Message Delivery</th>
<th>Memory Usage</th>
</tr>
</thead>
<tbody>
<tr>
<td>2-5 peers</td>
<td>&lt; 2 seconds</td>
<td>100% success</td>
<td>~5MB per peer</td>
</tr>
<tr>
<td>6-10 peers</td>
<td>2-4 seconds</td>
<td>99.8% success</td>
<td>~8MB per peer</td>
</tr>
<tr>
<td>11-15 peers</td>
<td>3-6 seconds</td>
<td>99.5% success</td>
<td>~12MB per peer</td>
</tr>
</tbody>
</table>
<h3>Best Practices for Performance</h3>
<ol>
<li>
<p><strong>Optimal Peer Limits</strong></p>
<pre class="prettyprint source lang-javascript"><code>// For most applications
mesh.setMaxPeers(8);  // Sweet spot for connectivity vs resources
mesh.setMinPeers(3);  // Ensures network resilience
</code></pre>
</li>
<li>
<p><strong>Enable All Optimizations</strong></p>
<pre class="prettyprint source lang-javascript"><code>mesh.setEvictionStrategy(true);  // Maintains optimal topology
mesh.setXorRouting(true);        // Reduces signaling overhead
mesh.setAutoDiscovery(true);     // Handles connections automatically
</code></pre>
</li>
<li>
<p><strong>Monitor Connection Health</strong></p>
<pre class="prettyprint source lang-javascript"><code>mesh.addEventListener('statusChanged', (event) => {
    if (event.type === 'warning') {
        console.warn('Network issue:', event.message);
        // Implement reconnection logic
    }
});
</code></pre>
</li>
</ol>
<h2>🔒 Security Considerations</h2>
<h3>Built-in Security Features</h3>
<ul>
<li><strong>Peer ID Generation</strong>: Uses <code>crypto.getRandomValues()</code> for cryptographically secure peer IDs</li>
<li><strong>WebRTC Encryption</strong>: Built-in DTLS encryption for all peer-to-peer communication</li>
<li><strong>Input Validation</strong>: All peer IDs and messages are validated before processing</li>
<li><strong>Message Limits</strong>: TTL and size limits prevent abuse and resource exhaustion</li>
</ul>
<h3>Deployment Security</h3>
<h4>Signaling Server Security</h4>
<pre class="prettyprint source lang-bash"><code># Always use HTTPS/WSS for signaling endpoints
https://your-signaling-server.com/signaling  # ✅ Secure
http://your-signaling-server.com/signaling   # ❌ Insecure

# Implement rate limiting
POST /signaling
X-Rate-Limit: 100 requests per minute per IP
</code></pre>
<h3>Security Best Practices</h3>
<ol>
<li>
<p><strong>Validate All Inputs</strong></p>
<pre class="prettyprint source lang-javascript"><code>// PeerPigeon automatically validates:
// - Peer ID format (hexadecimal, correct length)
// - Message content (type, size limits)
// - WebRTC message structure
</code></pre>
</li>
<li>
<p><strong>Implement Application-Level Security</strong></p>
<pre class="prettyprint source lang-javascript"><code>// Add your own message authentication
mesh.addEventListener('messageReceived', (event) => {
    if (!validateMessageSignature(event.content, event.from)) {
        console.warn('Ignoring message with invalid signature');
        return;
    }
    // Process trusted message
});
</code></pre>
</li>
<li>
<p><strong>Monitor for Abuse</strong></p>
<pre class="prettyprint source lang-javascript"><code>// Track message frequency per peer
const messageRates = new Map();
mesh.addEventListener('messageReceived', (event) => {
    const rate = trackMessageRate(event.from);
    if (rate > MAX_MESSAGES_PER_MINUTE) {
        mesh.disconnectPeer(event.from, 'rate limit exceeded');
    }
});
</code></pre>
</li>
</ol>
<h2>🛠️ Development &amp; Debugging</h2>
<h3>Running Tests</h3>
<pre class="prettyprint source lang-bash"><code># Install development dependencies
npm install

# Start local development server
npm run dev
# or
npx http-server -p 8080

# Open multiple browser tabs for testing
open http://localhost:8080/examples/browser/
open http://localhost:8080/examples/browser/
open http://localhost:8080/examples/browser/
</code></pre>
<h3>Debugging Tools</h3>
<h4>Built-in Debugging</h4>
<pre class="prettyprint source lang-javascript"><code>// Global mesh access in browser
window.peerPigeonMesh.getStatus();           // Network status
window.peerPigeonMesh.getPeers();            // Connected peers
window.peerPigeonMesh.getDiscoveredPeers();  // Discovered peers
window.peerPigeonMesh.debugConnectivity();   // Detailed connectivity info

// Force connections for testing
window.peerPigeonMesh.forceConnectToAllPeers();

// Component access
window.peerPigeonSignaling;    // SignalingClient instance
window.getPeerPigeonState();   // Complete application state
</code></pre>
<h4>Browser Developer Tools</h4>
<ol>
<li><strong>Console Logs</strong>: Detailed connection and message flow with peer ID prefixes</li>
<li><strong>Network Tab</strong>: Monitor signaling server communication patterns</li>
<li><strong>WebRTC Internals</strong>: Chrome's <code>chrome://webrtc-internals/</code> for connection debugging</li>
<li><strong>Application Tab</strong>: LocalStorage inspection for persistent state</li>
</ol>
<h4>Debugging Common Issues</h4>
<p><strong>Connection Problems:</strong></p>
<pre class="prettyprint source lang-javascript"><code>// Check connection prerequisites
console.log('Signaling connected:', mesh.getStatus().connected);
console.log('Discovered peers:', mesh.getDiscoveredPeers().length);
console.log('Connection attempts:', mesh.getConnectionAttempts());

// Force retry connections
mesh.getDiscoveredPeers().forEach(peer => {
    if (!mesh.hasPeer(peer.peerId)) {
        mesh.connectToPeer(peer.peerId);
    }
});
</code></pre>
<p><strong>Message Delivery Issues:</strong></p>
<pre class="prettyprint source lang-javascript"><code>// Check gossip protocol state
mesh.addEventListener('messageReceived', (event) => {
    console.log('Message path:', event.path);
    console.log('TTL remaining:', event.ttl);
    console.log('Seen messages:', mesh.gossipManager.seenMessages.size);
});
</code></pre>
<h2>🧪 Testing &amp; Development</h2>
<p>PeerPigeon includes a comprehensive testing framework with unit tests, integration tests, performance benchmarks, and automated CI/CD pipeline.</p>
<h3>Quick Start</h3>
<pre class="prettyprint source lang-bash"><code># Install dependencies
npm install

# Run all tests
npm test

# Run specific test suites
npm run test:unit          # Unit tests only
npm run test:integration   # Integration tests only
npm run test:custom        # Custom test runners

# Run with coverage
npm run test:coverage

# Performance benchmarks
npm run benchmark

# Linting
npm run lint
npm run lint:fix          # Auto-fix issues

# Full CI pipeline
npm run ci
</code></pre>
<h3>Test Structure</h3>
<pre class="prettyprint source"><code>test/
├── unit/                 # Unit tests (16 tests)
│   ├── crypto.test.js    # CryptoManager tests (7 tests)
│   └── mesh.test.js      # PeerPigeonMesh tests (9 tests)
├── integration/          # Integration tests (7 tests)
│   ├── simple.test.js    # Integration scenarios
│   └── integration-runner.js # Custom test runner
├── setup.js              # Jest configuration
├── runner.js             # Comprehensive test runner
└── benchmark.js          # Performance benchmarks
</code></pre>
<h3>Testing Framework Features</h3>
<ul>
<li><strong>🔧 Custom Test Runners</strong>: Built-in Node.js test runners for comprehensive testing</li>
<li><strong>🃏 Jest Integration</strong>: Modern testing framework with ES modules support and coverage reporting</li>
<li><strong>📊 Coverage Reports</strong>: Detailed HTML and LCOV coverage reports</li>
<li><strong>⚡ Performance Benchmarks</strong>: Crypto operations, mesh performance, and memory usage</li>
<li><strong>🔍 Linting</strong>: ESLint with standard configuration (0 errors, 0 warnings)</li>
<li><strong>🤖 CI/CD Pipeline</strong>: Automated testing with proper resource cleanup</li>
<li><strong>🛠️ Clean Test Termination</strong>: All tests complete without hanging processes</li>
<li><strong>⚡ Fast Execution</strong>: Unit tests ~0.26s, full suite ~1.2s</li>
</ul>
<h3>Available Commands</h3>
<pre class="prettyprint source lang-bash"><code># Using npm scripts
npm test                  # Jest tests (23/23 passing)
npm run test:unit         # Unit tests (16/16 passing)
npm run test:integration  # Integration tests (7/7 passing)
npm run test:custom       # Custom test runners
npm run test:all          # Comprehensive test suite
npm run test:coverage     # Coverage analysis
npm run test:watch        # Watch mode
npm run lint              # ESLint (0 errors, 0 warnings)
npm run lint:fix          # Auto-fix linting issues
npm run benchmark         # Performance benchmarks
npm run ci                # Full CI pipeline

# Using Makefile (shorter commands)
make test                 # Run tests
make lint                 # Run linting
make benchmark            # Run benchmarks
make coverage             # Generate coverage
make ci                   # Full CI check
make help                 # Show all commands
</code></pre>
<h3>Test Categories</h3>
<h4>Unit Tests (16 tests passing)</h4>
<ul>
<li><strong>CryptoManager (7 tests)</strong>: Encryption, decryption, key generation, signing</li>
<li><strong>PeerPigeonMesh (9 tests)</strong>: Core mesh functionality, message routing</li>
<li><strong>Resource Management</strong>: Timer cleanup, proper disconnection</li>
<li><strong>Memory Safety</strong>: No memory leaks or hanging processes</li>
</ul>
<h4>Integration Tests (7 tests passing)</h4>
<ul>
<li><strong>Peer Discovery</strong>: Network join/leave scenarios</li>
<li><strong>Message Propagation</strong>: End-to-end gossip protocol testing</li>
<li><strong>Network Resilience</strong>: Connection management and cleanup</li>
<li><strong>Multi-Peer Scenarios</strong>: Real-world mesh networking tests</li>
</ul>
<h4>Performance Benchmarks</h4>
<ul>
<li><strong>Crypto Performance</strong>: Key generation, encryption/decryption speed</li>
<li><strong>Mesh Operations</strong>: Peer connection, message routing efficiency</li>
<li><strong>Memory Usage</strong>: Memory leak detection, resource management</li>
<li><strong>Network Performance</strong>: Message throughput, latency analysis</li>
</ul>
<h3>Coverage Reports</h3>
<p>After running <code>npm run test:coverage</code>, open <code>coverage/index.html</code> to view detailed coverage reports including:</p>
<ul>
<li>Line coverage</li>
<li>Function coverage</li>
<li>Branch coverage</li>
<li>Statement coverage</li>
</ul>
<h3>Continuous Integration</h3>
<p>The project includes GitHub Actions workflows for:</p>
<ul>
<li><strong>Multiple Node.js versions</strong> (18.x, 20.x, 22.x)</li>
<li><strong>Automated testing</strong> on push/PR</li>
<li><strong>Security audits</strong></li>
<li><strong>Performance benchmarking</strong></li>
<li><strong>Coverage reporting</strong></li>
</ul>
<h3>Browser Testing Scenarios</h3>
<h4>Multi-Tab Testing</h4>
<pre class="prettyprint source lang-bash"><code># Open multiple browser tabs for mesh testing
npm run dev

# In separate terminal, open tabs
for i in {1..5}; do
    open &quot;http://localhost:8080/examples/browser/?debug=true&tab=$i&quot;
done
</code></pre>
<h4>Network Partition Testing</h4>
<pre class="prettyprint source lang-javascript"><code>// Simulate network partition in browser console
mesh.disconnectPeer(specificPeerId, 'testing partition');

// Monitor reconnection behavior
mesh.on('peerReconnected', (peerId) => {
    console.log('Peer reconnected after partition:', peerId);
});
</code></pre>
<h4>Encryption Testing</h4>
<pre class="prettyprint source lang-javascript"><code>// Test encryption in browser
await mesh.crypto.generateKeyPair();
const encrypted = await mesh.encryptMessage('test message', targetPeerId);
const decrypted = await mesh.decryptMessage(encrypted, senderPeerId);
console.log('Encryption test:', decrypted === 'test message');
</code></pre>
<p>setTimeout(() =&gt; {
console.log('Network recovered, connections:', mesh.getConnectedPeerCount());
}, 10000);</p>
<pre class="prettyprint source"><code>
#### Load Testing
```javascript
// Send messages rapidly to test gossip protocol
setInterval(() => {
    mesh.sendMessage(`Load test message ${Date.now()}`);
}, 1000);
</code></pre>
<h2>🤝 Contributing</h2>
<p>We welcome contributions! Here's how to get started:</p>
<h3>Development Setup</h3>
<pre class="prettyprint source lang-bash"><code># Fork and clone the repository
git clone https://github.com/your-username/pigon.git
cd pigon

# Create a feature branch
git checkout -b feature/amazing-improvement

# Make your changes and test thoroughly
npm run dev
# Test with multiple browser instances

# Commit with descriptive messages
git commit -m &quot;Add isolation prevention to peer discovery

- Implements lexicographic override when peer has no connections
- Prioritizes natural initiators over XOR distance
- Prevents permanent isolation in small networks
- Adds comprehensive logging for debugging&quot;

# Push and create pull request
git push origin feature/amazing-improvement
</code></pre>
<h3>Contribution Guidelines</h3>
<ol>
<li><strong>Test with Multiple Peers</strong>: Always test changes with 3-5 browser instances</li>
<li><strong>Maintain Backward Compatibility</strong>: Don't break existing API contracts</li>
<li><strong>Add Comprehensive Logging</strong>: Use consistent peer ID prefixes in logs</li>
<li><strong>Update Documentation</strong>: Include code examples and explanations</li>
<li><strong>Follow Code Style</strong>: Use consistent formatting and naming conventions</li>
</ol>
<h3>Areas for Contribution</h3>
<ul>
<li><strong>Performance Optimization</strong>: Improve connection speed and memory usage</li>
<li><strong>Security Enhancements</strong>: Add message authentication and rate limiting</li>
<li><strong>Testing Framework</strong>: Automated testing for mesh network scenarios</li>
<li><strong>Mobile Optimization</strong>: Improve performance on mobile browsers</li>
<li><strong>Documentation</strong>: Examples, tutorials, and API improvements</li>
</ul>
<h2>📄 License</h2>
<p>This project is licensed under the MIT License - see the <a href="LICENSE">LICENSE</a> file for details.</p>
<h2>🙏 Acknowledgments</h2>
<ul>
<li><strong>Kademlia DHT</strong>: Inspired the XOR distance routing algorithm (<a href="https://pdos.csail.mit.edu/~petar/papers/maymounkov-kademlia-lncs.pdf">Paper</a>)</li>
<li><strong>WebRTC Community</strong>: For providing the foundation of peer-to-peer communication</li>
<li><strong>Gossip Protocols</strong>: Epidemic algorithms research for reliable message propagation</li>
<li><strong>Open Source Community</strong>: For feedback, testing, and continuous improvement</li>
</ul>
<hr>
<p><strong>Quick Links:</strong></p>
<ul>
<li><a href="http://localhost:8080/examples/browser/">Live Demo</a> (after starting local server)</li>
<li><a href="docs/API.md">API Documentation</a></li>
<li><a href="docs/DEPLOYMENT.md">Deployment Guide</a></li>
<li><a href="https://github.com/danrayadev/pigon/issues">GitHub Issues</a></li>
<li><a href="CONTRIBUTING.md">Contributing Guidelines</a></li>
</ul></article>
    </section>






</div>

<nav>
    <h2><a href="index.html">Home</a></h2><h3>Classes</h3><ul><li><a href="CleanupManager.html">CleanupManager</a></li><li><a href="ConnectionManager.html">ConnectionManager</a></li><li><a href="EnvironmentDetector.html">EnvironmentDetector</a></li><li><a href="EvictionManager.html">EvictionManager</a></li><li><a href="GossipManager.html">GossipManager</a></li><li><a href="MeshOptimizer.html">MeshOptimizer</a></li><li><a href="PeerPigeonMesh.html">PeerPigeonMesh</a></li><li><a href="PeerPigeonMesh_PeerPigeonMesh.html">PeerPigeonMesh</a></li><li><a href="SignalingHandler.html">SignalingHandler</a></li><li><a href="StorageManager.html">StorageManager</a></li><li><a href="WebDHT.html">WebDHT</a></li></ul><h3>Global</h3><ul><li><a href="global.html#safeClearInterval">safeClearInterval</a></li><li><a href="global.html#safeClearTimeout">safeClearTimeout</a></li><li><a href="global.html#safeSetInterval">safeSetInterval</a></li><li><a href="global.html#safeSetTimeout">safeSetTimeout</a></li></ul>
</nav>

<br class="clear">

<footer>
    Documentation generated by <a href="https://github.com/jsdoc/jsdoc">JSDoc 4.0.4</a> on Thu Jul 24 2025 17:58:22 GMT-0500 (Central Daylight Time)
</footer>

<script> prettyPrint(); </script>
<script src="scripts/linenumber.js"> </script>
</body>
</html>